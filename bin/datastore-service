#!/usr/bin/env python
import sys, os, signal
import gobject
import dbus.service
import dbus.mainloop.glib
from olpc.datastore import DataStore, DS_LOG_CHANNEL, backingstore
import logging

# Path handling
profile = os.environ.get('SUGAR_PROFILE', 'default')
base_dir = os.path.join(os.path.expanduser('~'), '.sugar', profile)
repo_dir = os.path.join(base_dir, 'datastore')

# operate from the repo directory
if not os.path.exists(repo_dir): os.makedirs(repo_dir)

log_dir = os.path.join(base_dir, "logs")
if not os.path.exists(log_dir): os.makedirs(log_dir)

#os.chdir(repo_dir)

# setup logger
filename = None
if not sys.stdin.isatty():
    filename = os.path.join(log_dir, "datastore.log")

logging.basicConfig(level=logging.WARNING,
                    format="%(asctime)-15s %(levelname)s: %(message)s",
                    filename = filename,
                    )
# disable subsystem logging except where critical
logger = logging.getLogger(DS_LOG_CHANNEL)

# check for old lockfiles, the rules here are that we can't be
# connected to a tty. If we are not then in all likelyhood the process
# was started automatically, which hopefully implies a single instance
if not sys.stdin.isatty():
    lf = os.path.join(repo_dir, 'fulltext', 'flintlock')
    if os.path.exists(lf):
        logging.warning("Old lock file found -- removing.")
        os.unlink(lf)

        
# build the datastore
dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
bus = dbus.SessionBus()
connected = True

ds = DataStore()
ds.registerBackend(backingstore.FileBackingStore)
ds.registerBackend(backingstore.InplaceFileBackingStore)
ds.mount(repo_dir)
ds.complete_indexing()

# and run it 
logger.info("Starting Datastore %s" % (repo_dir))
mainloop = gobject.MainLoop()

def handle_disconnect():
    global connected
    connected = False

def handle_shutdown(signum, frame):
    global connected
    connected = False
    raise SystemExit("Shutting down on signal %s" % signum)

bus.set_exit_on_disconnect(False)
bus.add_signal_receiver(handle_disconnect,
                        signal_name='Disconnected',
                        dbus_interface='org.freedesktop.DBus.Local')

signal.signal(signal.SIGHUP, handle_shutdown)
signal.signal(signal.SIGTERM, handle_shutdown)

def main():
    # XXX: The context/sleep loop is a work around for what seems
    # to be the mainloop blocking in such a way that the indexer
    # thread doesn't run until new dbus messages come in...
    # I intend to track this down post trial-2
    # really awful
    import time
    context = mainloop.get_context()
    try:
        while connected:
            context.iteration(False)
            time.sleep(0.0025)

    except KeyboardInterrupt:
        logger.info("DataStore shutdown by user")
    except:
        logger.debug("Datastore shutdown with error",
                         exc_info=sys.exc_info())
     
main()

ds.stop()

#import hotshot
#p = hotshot.Profile('hs.prof')
#p.run('main()')

