#!/usr/bin/env python

""" Async index service for the Datastore.

Subscribes to the create/update/delete messages of the Datastore and
performs the indexing. When this service is enabled the Datastore
access the Xapian repository in read only mode.
"""


try: from ore.main import Application
except ImportError: Application = object

from olpc.datastore.datastore import DS_SERVICE, DS_OBJECT_PATH
from olpc.datastore.datastore import DS_DBUS_INTERFACE
from olpc.datastore.indexer import Indexer
import dbus
import dbus.mainloop.glib
import logging
import sys
import os
import signal

profile = os.environ.get('SUGAR_PROFILE', 'default')
base_dir = os.path.join(os.path.expanduser('~'), '.sugar', profile)
repo_dir = os.path.join(base_dir, 'datastore')
fulltext_dir = os.path.join(repo_dir, 'fulltext')

log_dir = os.path.join(base_dir, "logs")
if not os.path.exists(log_dir): os.makedirs(log_dir)

os.chdir(repo_dir)

# setup logger
filename = None
if not sys.stdin.isatty():
    filename = os.path.join(log_dir, "indexer.log")
logging.basicConfig(level=logging.DEBUG,
                    format="%(asctime)-15s %(levelname)s: %(message)s",
                    filename = filename,
                    )

logger = logging.getLogger('org.laptop.sugar.Indexer')
logger.setLevel(logging.DEBUG)

class IndexService(Application):
    def manage_options(self):
        self.parser.add_option("--olpc.fulltext.repo",
                               dest="fulltext_dir",
                               action="store", default='fulltext',
                               help="""Location of the FullText Repository""")


    def main(self):
        logging.debug('Starting the index service at %s' % self.options.fulltext_dir)
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        bus = dbus.SessionBus()
        self.fulltext = Indexer(self.options.fulltext_dir)
        self.fulltext.use_fulltext = True
        
        self.ds = bus.get_object(DS_SERVICE, DS_OBJECT_PATH)

        self.ds.connect_to_signal("Created", self.created,
                                  dbus_interface=DS_DBUS_INTERFACE)

        self.ds.connect_to_signal("Updated", self.updated,
                                  dbus_interface=DS_DBUS_INTERFACE)

        self.ds.connect_to_signal("Deleted", self.deleted,
                                  dbus_interface=DS_DBUS_INTERFACE)


        self.ds.connect_to_signal("Stopped", self.stopped,
                                  dbus_interface=DS_DBUS_INTERFACE)

        self.eventloop.run()

    def created(self, uid):
        """An object was created on the bus and we want to index it"""
        # because the file isn't encoded anywhere accessible in the
        # create call we must actually get the filename and trigger
        # the indexing on that
        filename = self.ds.get_filename(uid)
        r = None
        if filename:
            mime_type = self.ds.get_properties(uid).get('mime_type', None)
            r = self.fulltext.fulltext_index(uid, filename, mime_type)
        if r is True:
            logger.debug("index creation of %s" % uid)
        elif r is False:
            logger.debug("unable to index creation of  %s" % uid)
        else:
            logger.debug("nothing to index on creation of %s" % uid)
            
    def updated(self, uid):
        """An object was updated on the bus and we want to index it"""
        # because the file isn't encoded anywhere accessible in the
        # create call we must actually get the filename and trigger
        # the indexing on that
        filename = self.ds.get_filename(uid)
        r = None
        if filename:
            mime_type = self.ds.get_properties(uid).get('mime_type', None)
            print uid, filename, mime_type
            r = self.fulltext.fulltext_index(uid, filename, mime_type)
        if r is True:
            logger.debug("index update of %s" % uid)
        elif r is False:
            logger.debug("unable to index update of  %s" % uid)
        else:
            logger.debug("nothing to index on update of %s" % uid)
            
        
    def deleted(self, uid):
        """An object was updated on the bus and we want to index it"""
        # because the file isn't encoded anywhere accessible in the
        # create call we must actually get the filename and trigger
        # the indexing on that
        try:
            self.fulltext.fulltext_unindex(uid)
            logger.debug("unindex deletion  of %s" % uid);
        except KeyError: pass

        
    def stopped(self):
        """Respond to the datastore being stopped by shutting down
        ourselves"""
        self.fulltext.stop()
        self.eventloop.quit()


if __name__ == "__main__":
    def handle_shutdown(signum, frame):
        idx.stopped()
        print "shutdown cleanly"
        raise SystemExit("Shutting down on signal %s" % signum)

    signal.signal(signal.SIGHUP, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    idx = IndexService()
    ##idx()
    # w/o ore.main

    import gobject 
    idx.eventloop = gobject.MainLoop()
    class options(object): pass
    o = options()
    o.fulltext_dir = 'fulltext'
    idx.options = o
    try:
        idx.main()
    except:
        # force logging this one
        logger.setLevel(logging.DEBUG)
        logger.debug("Problem in index service",
                     exc_info=sys.exc_info())
        idx.stopped()


    
